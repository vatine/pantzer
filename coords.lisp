(in-package :pantzer)

(defvar *camera* nil)

(declaim (optimize (speed 3)))


(defclass coord ()
  ((x :accessor x :initarg :x :type double-float)
   (y :accessor y :initarg :y :type double-float)
   (z :accessor z :initarg :z :type double-float)))

;;; We only need a camera that can yaw (no pitch or roll needed)
(defclass camera (coord)
  ((angle :accessor angle :initarg :angle :type double-float)
   (focal :accessor focal :initarg :focal) 
   ))

(defun coord (x y z)
  (make-instance 'coord :x (coerce x 'double-float)
		 :y (coerce y 'double-float)
		 :z (coerce z 'double-float)))

(defun world-to-camera (w c &optional result)
  (let ((x-tmp (- (the-x w) (the-x c)))
	 (y-tmp (- (the-y w) (the-y c)))
	 (z-tmp (- (the-z w) (the-z c)))
	 (r1 (the-angle c))
	 (r2 (+ (/ pi 2.0d0)
		(the-angle c)))
	 (result (or result (make-instance 'coord))))
    (declare (double-float x-tmp y-tmp z-tmp r1 r2))
    (setf (x result) (+ (* (cos r1) x-tmp)
			(* (cos r2) y-tmp)))
    (setf (y result) (+ (* (sin r1) x-tmp)
			(* (sin r2) y-tmp)))
    (setf (z result) z-tmp)
    result))

(defun camera-to-screen (coord cam &optional clip)
  (let ((div (/ (the-y coord) (focal cam)))
	(screen-half (truncate +screen-side+ 2)))
    (declare ((signed-byte 16) screen-half)
	     (double-float div))
    (let ((sx (if (zerop div) (the-x coord) (/ (the-x coord) div)))
	  (sy (if (zerop div) (the-z coord) (/ (the-z coord) div))))
      (cond ((and clip
		 (<= -1.0d0 sx 1.0d0)
		 (<= -1.0d0 sy 1.0d0))
	     (list (round (+ screen-half (* screen-half sx)))
		   (round (+ screen-half (* (- screen-half) sy)))))
	    ((not clip)
	     (list (round (+ screen-half (* screen-half sx)))
		   (round (+ screen-half (* (- screen-half) sy)))))
	    (t nil)))))

(defun world-to-screen (w c &optional clip)
  (let ((screen-half (/ +screen-side+ 2))
	(x-tmp (- (the-x w) (the-x c)))
	(y-tmp (- (the-y w) (the-y c)))
	(z-tmp (- (the-z w) (the-z c)))
	(r1 (the-angle c))
	(r2 (+ (/ pi 2.0d0)
	       (the-angle c)))
	)
    (let ((cam-x (+ (* (cos r1) x-tmp)
		    (* (cos r2) y-tmp)))
	  (div (/ (+ (* (sin r1) x-tmp)
		     (* (sin r2) y-tmp))
		  (focal c)))
	  (cam-z z-tmp))
      (let ((sx (if (zerop div) cam-x (/ cam-x div)))
	    (sy (if (zerop div) cam-z (/ cam-z div))))
	(cond ((and clip
		 (<= -1.0d0 sx 1.0d0)
		 (<= -1.0d0 sy 1.0d0))
	     (list (round (+ screen-half (* screen-half sx)))
		   (round (+ screen-half (* (- screen-half) sy)))))
	    ((not clip)
	     (list (round (+ screen-half (* screen-half sx)))
		   (round (+ screen-half (* (- screen-half) sy)))))
	    (t nil))))))

(declaim (ftype (function (double-float) double-float) square))
(defun square (n)
  (declare (double-float n))  
  (* n n))


(declaim (ftype (function (coord coord) double-float) distance))
(defun distance (c1 c2)
  (let ((dx (- (the-x c2) (the-x c1)))
	(dy (- (the-y c2) (the-y c1)))
	(dz (- (the-z c2) (the-z c1))))
    (declare (double-float dx dy dz))
    (sqrt (+ (* dx dx) (* dy dy) (* dz dz)))))
